{"version":3,"names":[],"mappings":"","sources":["worker.js"],"sourcesContent":["/**\n * Search Engine WebWorker file\n * On startup (onmessage 'start') :\n *  - download the database\n *  - create the lunr index\n * When it receives a search query (onmessage 'search'), it triggers a search in lunr index and postMessage the results\n */\n\n// Download lunr search library (kind of a light lucene in the browser)\nimportScripts('./lunr.min.js');\n\n/**\n * Console.log a message : preprend 'worker' to identify messages coming from webpage and webworker\n *\n * @param {string}  message - the message to log\n * @param {*}       [value] - any type of value to log\n * @param {string}  [color] - hexadecimal color code to change the page prefix color\n * @param {boolean} [error] - if true use console.error\n */\nfunction logInfo(message, value, color, error) {\n  color = color || '#357ca5';\n  var data = ['%cworker', 'color: ' + color, message];\n  if (value) {\n    data.push(value);\n  }\n  if (error) {\n    console.error.apply(console, data);\n  } else {\n    console.log.apply(console, data);\n  }\n};\n\n/**\n * Wrapper around the standard 'postMessage' method in a webworker to log when we post a message\n *\n * @param {string} message - the message to send back to\n */\nfunction logAndPostMessage(message) {\n  logInfo('postMessage', message);\n  postMessage(message);\n};\n\n/**\n * Create a loader to dowload the database from an URL\n * Like jQuery.getJSON\n *\n * @constructor\n *\n * @param {string} url - the url to the database\n */\nfunction UrlDataLoader(url) {\n  this.url = url;\n\n  /** @function load - takes 3 callback : success, error, onprogress. Each with one argument. */\n  this.load = function(successCallback, errorCallback, progressCallbak) {\n    logInfo('downloading from database at ' + this.url);\n\n    // Create request\n    var request = new XMLHttpRequest();\n    request.open('GET', this.url, true);\n\n    // Manage onprogress\n    if (request.onprogress) {\n      request.onprogress = function(evt) {\n        if (evt.lengthComputable) {  // If computable, returns percents. The view will display a progress bar.\n          progressCallbak(Math.round((evt.loaded / evt.total) * 100));\n        } else {  // If not computable, returns null. The view will display a spinner.\n          progressCallbak(null);\n        }\n      };\n    } else {  // If XHR2 not available, fallback to spinner in the view\n      progressCallbak(null);\n    }\n\n    // Download ended (successfully or server error)\n    request.onload = function() {\n      logInfo('database downloaded');\n      if (this.status >= 200 && this.status < 400) {\n        successCallback(JSON.parse(this.response));\n      } else {\n        errorCallback('Unable to download database');\n      }\n    };\n\n    // Error on transfert (most of the time connection error)\n    request.onerror = function() {\n      errorCallback('Unable to download database');\n    };\n\n    // Start the XHR request\n    request.send();\n  };\n};\n\n/**\n * The SearchEngine encapsulating lunr index\n *\n * @constructor\n *\n * @param {Function} workerEventEmitter - a function to send messages when an event occurred in the engine.\n *                                        Most of the time, the WebWorker postMessage function\n */\nfunction SearchEngine(workerEventEmitter) {\n  /** Provide method for each kind of events raised by the search engine */\n  this.emitter = {\n    /** @function sendDownloadEvent - called when download start and each time the download has progressed by a bit */\n    sendDownloadEvent: function(downloaded) {\n      workerEventEmitter({event: 'loading', type: 'download', value: downloaded});\n    },\n    /** @function sendIndexingEvent - called when indexing start and each time indexing has progressed by a bit */\n    sendIndexingEvent: function(indexed) {\n      workerEventEmitter({event: 'loading', type: 'indexing', value: indexed});\n    },\n    /** @function sendIndexingEvent - called when search engine is ready to received search queries */\n    sendReadyEvent: function() {\n      workerEventEmitter({event: 'loading', type: 'ready', value: null});\n    },\n    /** @function sendIndexingEvent - called when search engine has finished to compute a search query. send results */\n    sendResultEvent: function(articles, term) {\n      workerEventEmitter({event: 'result', value: articles, term: term});\n    },\n    /** @function sendIndexingEvent - called when an error occured. kills the webworker. */\n    sendErrorEvent: function(message) {\n      workerEventEmitter({event: 'error', value: message});\n      throw Error(message);\n    }\n  };\n\n  // While loaded is false, no search query can be processed. Swithes to true when the search engine is ready.\n  this.loaded = false;\n\n  // The lunr index\n  this._index = lunr(function() {\n    this.field('title', {boost: 10});\n    this.field('keywords', {boost: 5});\n    this.field('description');\n    this.ref('id');\n\n    /**\n     * Lunr returns a doc { ref: id, score: relevance } after search\n     * index plugin to :\n     *     - override the default `add` method to keep a reference to each full document in the index in a\n     *       new `database` attribute\n     *     - override the default search method to returns the full document with the score instead of the lunr\n     *       default doc\n     */\n    this.use(function(idx) {\n      idx.database = {};  // Map to find a document by its id\n\n      // Override default add method to keep reference to all the documents in the index by their id.\n      var refOriginalAdd = idx.add;\n      idx.add = function(doc, emitEvent) {\n        idx.database[doc[idx._ref]] = doc;\n        refOriginalAdd.apply(idx, [doc, emitEvent]);\n      };\n\n      // Override default search method to returns the real document instead of the lunr result doc\n      var refOriginalSearch = idx.search;\n      idx.search = function (query) {\n        return refOriginalSearch.call(idx, query).map(function(doc) {\n          var article = idx.database[doc.ref];\n          article.score = doc.score;\n          return article;\n        });\n      };\n    });\n  });\n\n  /** Build the lunr index. Called when the data have been downloaded */\n  this._build = function(articles) {\n    var databaseLength = articles.length;\n    var nbIndexed = 0;  // nb of document already indexed\n    var lastProgress = null;  // Last progress value send to the webpage\n\n    articles.forEach(function(article) {\n      this._index.add(article, false);\n      nbIndexed++;\n\n      // Only send indexation progress back to the page if it has changed\n      var progress = Math.floor((nbIndexed / databaseLength) * 100);\n      if (progress !== lastProgress) {\n        this.emitter.sendIndexingEvent(progress);\n        lastProgress = progress;\n      }\n    }.bind(this));\n\n    this.loaded = true;\n    this.emitter.sendReadyEvent();\n  };\n\n  /** Trigger a search query and emit the results */\n  this.search = function(term) {\n    if (!this.loaded) this.emitter.sendErrorEvent('Searchengine not started yet');\n    this.emitter.sendResultEvent(this._index.search(term), term);\n  };\n\n  /** Starts the search engine (download data, build index and switch state to loaded) */\n  this.start = function(dataLoader) {\n    if (this.loaded) this.emitter.sendErrorEvent('Searchengine already started');\n    dataLoader.load(\n      this._build.bind(this),\n      this.emitter.sendErrorEvent,\n      this.emitter.sendDownloadEvent\n    );\n  };\n};\n\n// The search engine instance\nvar edSearchEngine = new SearchEngine(logAndPostMessage);\n\nlogInfo('started');\n\n// WebWorker message input (coming from webpage)\nonmessage = function(e) {\n  logInfo('onmessage', e.data);\n  switch (e.data.action) {\n    case 'start':\n      logInfo('starting search engine');\n      edSearchEngine.start(new UrlDataLoader(e.data.url));\n      break;\n    case 'search':\n      edSearchEngine.search(e.data.value);\n      break;\n    default:\n      logInfo('unrecognized action ', e.data.action);\n  };\n};\n"],"file":"worker.js","sourceRoot":"/source/"}