{"version":3,"names":[],"mappings":"","sources":["main.js"],"sourcesContent":["/**\n * Site JS File\n * Create the search engine webworker, bind events with the search field and manage communication between the 2.\n * A VuJS component is tasked to update the view\n */\n\n;(function(document, Vue, Rx, config){\n\n// Base URL of the database with cover images and articles text\nvar baseDatabaseUrl = config.database.replace(/\\/$/g, '');\n\n/**\n * -----------------------------------------------\n * Vue Component and MISC functions\n * -----------------------------------------------\n */\n\n/**\n * Mapping of a type to its magazine name\n */\nvar typeToMagNameMapping = {\n  glmf: 'GNU Linux Magazine France',\n  glmfhs: 'GNU Linux Magazine France Hors Séries',\n  lp: 'Linux Pratique',\n  lphs: 'Linux Pratique Hors Séries',\n  le: 'Linux Essentiel',\n  lehs: 'Linux Essentiel Hors Séries',\n  misc: 'MISC',\n  mischs: 'MISC Hors Séries',\n  os: 'Open Silicium',\n  hm: 'Hackable Magazine'\n};\n\n/**\n * Object used in VueJS Component to bind values to the view\n *\n * @namespace\n * @property {boolean}   loading           - while true display loading animation\n * @property {string}    loadingStep       - switch loading message (download, indexing)\n * @property {number}    loadingProgress   - update progress bar if supported by loadingStep\n *                                           (integer : progressbar, null: spinner, undefined: nothing)\n * @property {boolean}   atLeastOneSearch  - true if the user has started at least one search\n * @property {Article[]} searchResult      - display search results\n * @property {boolean}   searchInProgress  - if the webworker is computing the result of the search query\n * @property {string}    latestSearchTerms - latest terms searched. Used to compare with webworker search result to see if\n *                                           we need to trigger a new search query\n * @property {boolean}   displayError      - if we need to disable search and display error message\n */\nvar appState = {\n  loading: true,\n  loadingStep: 'download',\n  loadingProgress: undefined,\n  atLeastOneSearch: false,\n  searchResult: [],\n  searchInProgress: false,\n  latestSearchTerms: null,\n  displayError: false\n};\n\n// Register vuejs filter to display a magazine name from its type\nVue.filter('typeToMagName', function (value) {\n  if (typeToMagNameMapping.hasOwnProperty(value)) {\n    return typeToMagNameMapping[value];\n  }\n  return 'n/a';\n});\n\n// Register vuejs filter to get the cover url of an article\nVue.filter('articleToCover', function (article) {\n  var magNumber = \"000\".substring(0, 3 - (\"\" + article.number).length) + article.number;\n  return baseDatabaseUrl + \"/\" + article.type + '/' + magNumber + '.jpg';\n});\n\n// VueJS component to update HTML when object appState changes\nvar appComponent = new Vue({\n  el: '#app',\n  data: appState,\n  methods: {\n    onSubmit: function() {}  // Prevent standard HTML form submit. We use RxJS to watch for input changes\n  }\n});\n\n/**\n * Console.log a message : preprend page to identify messages coming from webpage and webworker\n *\n * @param {string}  message - the message to log\n * @param {*}       [value] - any type of value to log\n * @param {string}  [color] - hexadecimal color code to change the page prefix color\n * @param {boolean} [error] - if true use console.error\n */\nfunction logInfo(message, value, color, error) {\n  color = color || '#008d4c';\n  var data = ['%cpage', 'color: ' + color, message];\n  if (value) {\n    data.push(value);\n  }\n  if (error) {\n    console.error.apply(console, data);\n  } else {\n    console.log.apply(console, data);\n  }\n};\n\n/**\n * Function to handle any error.\n * It logs the error and display the error message\n *\n * @param {Error} e - the error raised\n */\nfunction handleError(e) {\n  appState.loading = false;\n  appState.displayError = true;\n  appState.searchInProgress = false;\n  appState.searchResult = [];\n  logInfo(e, null, null, true);\n}\n\n\n/**\n * -----------------------------------------------\n * SearchEngine Webworker\n * -----------------------------------------------\n */\n\n// Create SearchEngine in a WebWorker\nvar searchEngineWorker = Rx.DOM.fromWorker('worker.js');\nsearchEngineWorker.sendMessage = function(message) {\n  logInfo('onNext', message);\n  this.onNext(message);\n};\nvar searchEngineSharedObservable = searchEngineWorker\n  .share()\n  .map(function(e) {\n    return e.data;\n  });\n\n// Listen for loading (database downloading and indexing) messages from SearchEngine WebWorker\nsearchEngineSharedObservable.filter(function(data) {\n  return data.event === 'loading';\n}).subscribe(\n  function (data) {\n    logInfo('loading', data);\n    appState.loadingProgress = data.value;\n    appState.loadingStep = data.type;\n    appState.loading = data.type !== 'ready';  // Final step when SearchEngine is ready\n  },\n  handleError\n);\n\n// Listen for search result messages from SearchEngine WebWorker\nsearchEngineSharedObservable.filter(function(data) {\n  return data.event === 'result';\n}).subscribe(\n  function (data) {\n    logInfo('result', data);\n    if (data.term === appState.latestSearchTerms) {\n      logInfo('result display', '\"' + data.term + '\"');\n      appState.searchInProgress = false;\n      appState.searchResult = data.value;\n    } else {\n      logInfo('result does not match latest search term. Trigger new one', {received: data.term, latest: appState.latestSearchTerms});\n      searchEngineWorker.sendMessage({action: 'search', value: appState.latestSearchTerms});\n    }\n  },\n  handleError\n);\n\n// Trigger SearchEngine WebWorker indexation.\nsearchEngineWorker.sendMessage({action: 'start', url: baseDatabaseUrl + '/articles.json'});\n\n\n/**\n * -----------------------------------------------\n * Search Field event Streams\n * -----------------------------------------------\n */\n\nvar searchField = document.querySelector('#search-input');\nvar keyUpSearchStream = Rx.DOM.keyup(searchField);\nvar enterKeyPressedStream = keyUpSearchStream  // Returns input field value when Enter key is pressed\n  .filter(function (e) {\n    return e.keyCode == 13\n  })\n  .pluck('target', 'value');\nvar keyUpThrottledSearchStream = keyUpSearchStream  // Returns input field value debounced\n    .pluck('target', 'value')\n    .debounce(500)\n    .distinctUntilChanged();\n\n// Watch for first key pushed in search field to stick the search field at the top of the page (kind of like Google Search)\nkeyUpSearchStream.take(1).subscribe(function(e) {\n  appState.atLeastOneSearch = true;\n});\n\n// Handle form submit or clicks on submit button\nvar submitButton = document.querySelector('#search-submit');\nvar clickSubmitStream = Rx.Observable.fromEvent(submitButton, 'click')  // Returns input field value when form submitted or submit button clicked\n  .map(function(){\n    return searchField.value;\n  });\n\n// Watch for all streams which can trigger a search\nRx.Observable.merge([clickSubmitStream, enterKeyPressedStream, keyUpThrottledSearchStream])\n  .distinctUntilChanged()\n  .subscribe(function(searchTerms) {\n    // Trigger search\n    appState.latestSearchTerms = searchTerms;\n    if (!appState.searchInProgress && searchTerms) {  // If no search in progress, launch one\n      appState.searchInProgress = true;\n      searchEngineWorker.sendMessage({action: 'search', value: searchTerms});\n    } else if (!searchTerms) {  // If empty search terms, cancel search\n      appState.searchInProgress = false;\n      appState.searchResult = [];\n      logInfo('empty terms - stop search');\n    } else {  // Else if search already in progress, stores term to launch search when the current one ends\n      appState.searchInProgress = true;\n      logInfo('search already in progress - storing term', '\"' + searchTerms + '\"');\n    }\n  });\n\n})(document, Vue, Rx, edConfig);\n"],"file":"main.js","sourceRoot":"/source/"}